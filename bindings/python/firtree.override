%%
headers
#include <Python.h>
#include <pyglib.h> 
#include <pygobject.h> 

#include <firtree/firtree-kernel.h>
%%
init
%%
modulename pyfirtree
%%
import gobject.GObject as PyGObject_Type
%%
ignore-glob
  *_get_type                            
  _*
  *_ref
  *_unref
%%
override firtree_kernel_compile_from_source kwargs
static PyObject*
_wrap_firtree_kernel_compile_from_source(PyGObject* self, PyObject *args, PyObject *kwargs) 
{
    static char *kwlist[] = { "lines", "kernel_name" };

    PyObject* lines = NULL;
    char* kernel_name = NULL;

    if(!PyArg_ParseTupleAndKeywords(args, kwargs,
                "O|s:Kernel.compile_from_source", kwlist,
                &lines, &kernel_name))
    {
        return NULL;
    }

    /* lines may be a sequence, in which case the string
     * value of it's items is used or a non-sequence and the 
     * string value is used directly. */
    gboolean rv = FALSE;
    if(PyString_Check(lines)) {
        /* it is a string. */
        gchar* str = PyString_AS_STRING(lines);
        rv = firtree_kernel_compile_from_source(FIRTREE_KERNEL(self->obj), 
                &str, 1, kernel_name);
    } else if(PySequence_Check(lines)) {
        /* it is a sequence */
        guint i = 0;
        guint n_items = PySequence_Length(lines);
        GArray* str_array = g_array_sized_new(FALSE, FALSE,
                sizeof(gchar*), n_items);
        gboolean all_are_strings = TRUE;

        for(i=0; i<n_items; ++i)
        {
            PyObject* item = PySequence_ITEM(lines, i);
            gchar* str_val = NULL;
            if(PyString_Check(item)) {
                str_val = PyString_AS_STRING(item);
            } else {
                all_are_strings = FALSE;
            }
            g_array_append_val(str_array, str_val);
            Py_DECREF(item);
        }

        if(all_are_strings) {
            rv = firtree_kernel_compile_from_source(FIRTREE_KERNEL(self->obj), 
                    (gchar**)(str_array->data), str_array->len, kernel_name);
            g_array_free(str_array, TRUE);
        } else {
            g_array_free(str_array, TRUE);

            PyErr_SetString(PyExc_TypeError, "Sequence elements must all be strings.");
            return NULL;
        }

    } else {
        PyErr_SetString(PyExc_TypeError, "Expected a string or sequence of strings.");
        return NULL;
    }

    return PyBool_FromLong((long)rv);
}
%%
override firtree_kernel_get_compile_log kwargs
static PyObject*
_wrap_firtree_kernel_get_compile_log(PyGObject* self, PyObject *args)
{
    /* We expect no parameters */
    if(!PyArg_ParseTuple(args, ":Kernel.get_compile_log"))
    {
        return NULL;
    }

    guint n_log_lines = 0;
    gchar** compile_log = 
        firtree_kernel_get_compile_log(FIRTREE_KERNEL(self->obj), &n_log_lines);

    if(NULL == compile_log) {
        Py_INCREF(Py_None);
        return Py_None;
    }

    PyObject* log_tuple = PyTuple_New(n_log_lines);
    if(NULL == log_tuple) {
        return NULL;
    }

    guint i;
    for(i = 0; i<n_log_lines; ++i) {
        PyObject* new_str = PyString_FromString(compile_log[i]);
        PyTuple_SET_ITEM(log_tuple, i, new_str);
    }

    return log_tuple;
}
%%
override firtree_kernel_argument_changed kwargs
static PyObject *
_wrap_firtree_kernel_argument_changed(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "arg_name", NULL };
    char *arg_name;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:FirtreeKernel.argument_changed", kwlist, &arg_name))
        return NULL;
    
    firtree_kernel_argument_changed(FIRTREE_KERNEL(self->obj),
            g_quark_from_string(arg_name));
    
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override firtree_kernel_get_argument_value kwargs
static PyObject *
_wrap_firtree_kernel_get_argument_value(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "arg_name", NULL };
    char *arg_name;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:FirtreeKernel.get_argument_value", kwlist, &arg_name))
        return NULL;
    
    GQuark arg_quark = g_quark_from_string(arg_name);
    FirtreeKernelArgumentSpec* spec = firtree_kernel_get_argument_spec(
            FIRTREE_KERNEL(self->obj), arg_quark);

    /* If no spec, throw a key error */
    if(NULL == spec) {
        PyObject* err_str = PyString_FromFormat("No such argument: %s.", arg_name);
        PyErr_SetObject(PyExc_KeyError, err_str);
        Py_DECREF(err_str);
        return NULL;
    }

    GValue* arg_value = firtree_kernel_get_argument_value(
            FIRTREE_KERNEL(self->obj), arg_quark);
    if(NULL == arg_value)
    {
        Py_INCREF(Py_None);
        return Py_None;
    }

    return pyg_value_as_pyobject(arg_value, TRUE);
}
%%
override firtree_kernel_set_argument_value kwargs
static PyObject *
_wrap_firtree_kernel_set_argument_value(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "arg_name", "value", NULL };
    char *arg_name;
    PyObject* value;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                "sO:FirtreeKernel.set_argument_value", kwlist,
                &arg_name, &value))
        return NULL;
    
    GQuark arg_quark = g_quark_from_string(arg_name);
    GValue arg_value = {0,};
    
    FirtreeKernelArgumentSpec* spec = firtree_kernel_get_argument_spec(
            FIRTREE_KERNEL(self->obj), arg_quark);

    /* If no spec, throw a key error */
    if(NULL == spec) {
        PyObject* err_str = PyString_FromFormat("No such argument: %s.", arg_name);
        PyErr_SetObject(PyExc_KeyError, err_str);
        Py_DECREF(err_str);
        return NULL;
    }

    g_value_init(&arg_value, spec->type);
    if(pyg_value_from_pyobject(&arg_value, value)) {
        PyObject* err_str = PyString_FromFormat(
                "Argument is expected to be of type %s.",
                g_type_name(spec->type));
        PyErr_SetObject(PyExc_TypeError, err_str);
        Py_DECREF(err_str);
        return NULL;
    }

    gboolean rv = firtree_kernel_set_argument_value(
            FIRTREE_KERNEL(self->obj), arg_quark, &arg_value);

    g_value_unset(&arg_value);

    if(!rv) {
        PyErr_SetString(PyExc_ValueError, "Could not set argument value.");
        return NULL;
    }

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override firtree_kernel_get_argument_spec kwargs
static PyObject *
_wrap_firtree_kernel_get_argument_spec(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "arg_name", NULL };
    char *arg_name;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                "s:FirtreeKernel.get_argument_spec", kwlist,
                &arg_name))
        return NULL;
    
    GQuark arg_quark = g_quark_from_string(arg_name);

    FirtreeKernelArgumentSpec* spec = firtree_kernel_get_argument_spec(
            FIRTREE_KERNEL(self->obj), arg_quark);

    /* If no spec, throw a key error */
    if(NULL == spec) {
        PyObject* err_str = PyString_FromFormat("No such argument: %s.", arg_name);
        PyErr_SetObject(PyExc_KeyError, err_str);
        Py_DECREF(err_str);
        return NULL;
    }

    /* Create a tuple to hold spec. */
    PyObject* spec_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(spec_tuple, 0, PyString_FromString(arg_name));
    PyTuple_SET_ITEM(spec_tuple, 1, pyg_type_wrapper_new(spec->type));
    PyTuple_SET_ITEM(spec_tuple, 2, PyBool_FromLong((long)spec->is_static));

    return spec_tuple;
}
%%
override firtree_kernel_list_arguments kwargs
static PyObject *
_wrap_firtree_kernel_list_arguments(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                ":FirtreeKernel.list_arguments", kwlist))
        return NULL;

    guint n_args = 0;
    GQuark* arg_list = firtree_kernel_list_arguments(
            FIRTREE_KERNEL(self->obj), &n_args);

    if(NULL == arg_list) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    
    /* Create a tuple to hold result. */
    PyObject* arg_tuple = PyTuple_New(n_args);
    guint i;
    for(i=0; i<n_args; ++i) {
        PyTuple_SET_ITEM(arg_tuple, i, PyString_FromString(g_quark_to_string(arg_list[i])));
    }

    return arg_tuple;
}
%%
// vim:sw=4:ts=4:cindent:et:filetype=c

