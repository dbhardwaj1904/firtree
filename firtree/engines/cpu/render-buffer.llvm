; ModuleID = 'render-buffer'

; This is the compiled LLVM equivalent of render-buffer.c.

define void @render_buffer_uc_4(i8* nocapture %buffer, i32 %width, i32 %height, i32 %row_stride, float* nocapture %extents) nounwind {
entry:
	%0 = load float* %extents, align 4		; <float> [#uses=1]
	%1 = getelementptr float* %extents, i32 1		; <float*> [#uses=1]
	%2 = load float* %1, align 4		; <float> [#uses=1]
	%3 = getelementptr float* %extents, i32 2		; <float*> [#uses=1]
	%4 = load float* %3, align 4		; <float> [#uses=1]
	%5 = uitofp i32 %width to float		; <float> [#uses=1]
	%6 = fdiv float %4, %5		; <float> [#uses=1]
	%7 = getelementptr float* %extents, i32 3		; <float*> [#uses=1]
	%8 = load float* %7, align 4		; <float> [#uses=1]
	%9 = uitofp i32 %height to float		; <float> [#uses=1]
	%10 = fdiv float %8, %9		; <float> [#uses=1]
	%11 = icmp eq i32 %height, 0		; <i1> [#uses=2]
	br i1 %11, label %return, label %bb.nph32

bb.nph32:		; preds = %entry
	%12 = icmp eq i32 %width, 0		; <i1> [#uses=2]
	br i1 %12, label %return, label %bb.nph32.split

bb.nph32.split:		; preds = %bb.nph32
	%umax37 = select i1 %11, i32 1, i32 %height		; <i32> [#uses=1]
	br label %bb

bb:		; preds = %bb15, %bb.nph32.split
	%row.031 = phi i32 [ 0, %bb.nph32.split ], [ %indvar.next35, %bb15 ]		; <i32> [#uses=2]
	%y.030 = phi float [ %2, %bb.nph32.split ], [ %27, %bb15 ]		; <float> [#uses=2]
	%dest_coord.129 = phi <2 x float> [ undef, %bb.nph32.split ], [ %tmp19, %bb15 ]		; <<2 x float>> [#uses=1]
	%13 = mul i32 %row.031, %row_stride		; <i32> [#uses=1]
	%umax = select i1 %12, i32 1, i32 %width		; <i32> [#uses=1]
	br label %bb1

bb1:		; preds = %bb1, %bb
	%col.027 = phi i32 [ 0, %bb ], [ %indvar.next, %bb1 ]		; <i32> [#uses=2]
	%x.025 = phi float [ %0, %bb ], [ %26, %bb1 ]		; <float> [#uses=2]
	%dest_coord.024 = phi <2 x float> [ %dest_coord.129, %bb ], [ %tmp19, %bb1 ]		; <<2 x float>> [#uses=1]
	%pixel.026.rec = shl i32 %col.027, 2		; <i32> [#uses=1]
	%.sum = add i32 %13, %pixel.026.rec		; <i32> [#uses=4]
	%pixel.026 = getelementptr i8* %buffer, i32 %.sum		; <i8*> [#uses=1]
	%tmp = insertelement <2 x float> %dest_coord.024, float %x.025, i32 0		; <<2 x float>> [#uses=1]
	%tmp19 = insertelement <2 x float> %tmp, float %y.030, i32 1		; <<2 x float>> [#uses=3]
	%14 = tail call <4 x float> @sample(<2 x float> %tmp19) nounwind		; <<4 x float>> [#uses=4]
	%tmp20 = extractelement <4 x float> %14, i32 0		; <float> [#uses=1]
	%15 = mul float %tmp20, 2.550000e+02		; <float> [#uses=1]
	%16 = fptoui float %15 to i8		; <i8> [#uses=1]
	store i8 %16, i8* %pixel.026, align 1
	%tmp21 = extractelement <4 x float> %14, i32 1		; <float> [#uses=1]
	%17 = mul float %tmp21, 2.550000e+02		; <float> [#uses=1]
	%18 = fptoui float %17 to i8		; <i8> [#uses=1]
	%pixel.026.sum = add i32 %.sum, 1		; <i32> [#uses=1]
	%19 = getelementptr i8* %buffer, i32 %pixel.026.sum		; <i8*> [#uses=1]
	store i8 %18, i8* %19, align 1
	%tmp22 = extractelement <4 x float> %14, i32 2		; <float> [#uses=1]
	%20 = mul float %tmp22, 2.550000e+02		; <float> [#uses=1]
	%21 = fptoui float %20 to i8		; <i8> [#uses=1]
	%pixel.026.sum39 = add i32 %.sum, 2		; <i32> [#uses=1]
	%22 = getelementptr i8* %buffer, i32 %pixel.026.sum39		; <i8*> [#uses=1]
	store i8 %21, i8* %22, align 1
	%tmp23 = extractelement <4 x float> %14, i32 3		; <float> [#uses=1]
	%23 = mul float %tmp23, 2.550000e+02		; <float> [#uses=1]
	%24 = fptoui float %23 to i8		; <i8> [#uses=1]
	%pixel.026.sum40 = add i32 %.sum, 3		; <i32> [#uses=1]
	%25 = getelementptr i8* %buffer, i32 %pixel.026.sum40		; <i8*> [#uses=1]
	store i8 %24, i8* %25, align 1
	%26 = add float %x.025, %6		; <float> [#uses=1]
	%indvar.next = add i32 %col.027, 1		; <i32> [#uses=2]
	%exitcond = icmp eq i32 %indvar.next, %umax		; <i1> [#uses=1]
	br i1 %exitcond, label %bb15, label %bb1

bb15:		; preds = %bb1
	%27 = add float %y.030, %10		; <float> [#uses=1]
	%indvar.next35 = add i32 %row.031, 1		; <i32> [#uses=2]
	%exitcond38 = icmp eq i32 %indvar.next35, %umax37		; <i1> [#uses=1]
	br i1 %exitcond38, label %return, label %bb

return:		; preds = %bb15, %bb.nph32, %entry
	ret void
}

declare <4 x float> @sample(<2 x float>)

